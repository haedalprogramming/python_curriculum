# 이진 탐색(Binary Search)이란?
# 1부터 100 사이의 숫자 중 하나를 맞추는 업/다운 게임을 생각해봅시다.
# "1인가요?", "2인가요?"... 이렇게 묻는 바보는 없겠죠? (이게 선형 탐색)
# 대부분 **"50!"**이라고 외칩니다. 왜냐고요? 
# 정답이 50보다 크면 1~49는 싹 다 버릴 수 있으니까요.
# 이렇게 범위를 절반씩 뚝뚝 잘라내며 찾는 방법이 이진 탐색입니다.
# 절대 규칙: 정렬(Sorting)(매우 중요) 이진 탐색은 데이터가 반드시 순서대로 정렬되어 있어야만 쓸 수 있습니다.
# 뒤죽박죽 섞인 책장에서는 "가운데 꽂힌 책"이 무엇인지 의미가 없기 때문입니다.
# 얼마나 빠른가요?
# 데이터가 1000개일 때:선형 탐색: 운 없으면 1000번 다 봐야 함.
# 이진 탐색: 단 10번이면 무조건 찾음. ($2^{10} = 1024$)
# 데이터가 40억 개일 때:선형 탐색: 40억 번... (컴퓨터도 힘듦)이진 탐색: 단 32번. (엄청난 속도 차이!)
# ==========================================
# 이진 탐색 (Up/Down 게임의 원리)
# ==========================================

# [중요] 이진 탐색은 데이터가 반드시 '정렬'되어 있어야 합니다.
data = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19] # 오름차순 정렬됨
target = 19 # 찾고 싶은 숫자

print(f"전체 데이터: {data}")
print(f"찾는 숫자: {target}")
print("-" * 30)

# 탐색 범위 설정 (인덱스 기준)
start = 0              # 맨 앞
end = len(data) - 1    # 맨 뒤
count = 0              # 몇 번 만에 찾나?

while start <= end:
    count += 1
    
    # 중간 위치 계산 ( // 는 나눗셈의 몫(정수)만 구함)
    mid = (start + end) // 2 
    mid_value = data[mid]
    
    print(f"[{count}회차] 검색 범위: 인덱스 {start}~{end}")
    print(f"   --> 중간값 확인: {mid_value}")
    
    if mid_value == target:
        print(f"\n🎉 찾았다! {target}은 {mid}번 인덱스에 있습니다.")
        print(f"🚀 선형 탐색이었다면 7번 걸렸겠지만, 이진 탐색은 {count}번 만에 성공!")
        break
    
    elif mid_value < target:
        # 중간값이 정답보다 작다? -> 정답은 오른쪽(더 큰 쪽)에 있다.
        # 시작점을 중간 다음으로 땡겨옴 (Up!)
        start = mid + 1
        print("   --> UP! (오른쪽 탐색)")
        
    else:
        # 중간값이 정답보다 크다? -> 정답은 왼쪽(더 작은 쪽)에 있다.
        # 끝점을 중간 전으로 땡겨옴 (Down!)
        end = mid - 1
        print("   --> DOWN! (왼쪽 탐색)")

print("-" * 30)
