# [슬라이드 기획안] 23차시: 이진 탐색

## 1. 기획 개요

| 항목 | 내용 |
|------|------|
| **수업명** | [해달에듀] 파이썬 프로그래밍 23차시 - 이진 탐색 |
| **대상** | 초중고 학생 (코딩 초보자) |
| **총 슬라이드** | 35장 |
| **학습 목표** | 이진 탐색의 원리를 이해하고, 정렬된 데이터에서 효율적으로 검색할 수 있다 |
| **실습 코드** | `23-1-binary_search.py`, `23-2-practice_game.py` |
| **디자인 컨셉** | 메인 컬러: #FFD506, 반으로 나누기 비유 |

---

## 2. 상세 슬라이드 구성안

### PART 1. 도입 (Intro) : 4장

**목표: 흥미 유발 및 이진 탐색 소개**

| 번호 | 유형 | 화면 구성 및 내용 | 디자인/연출 포인트 |
|------|------|-------------------|-------------------|
| **01** | 표지 | **[제목] 반으로 나눠서 찾기!** ⚡ 이진 탐색 (Binary Search) **[부제] 23차시 \| 해달에듀** | 배경: #FFD506, 번개 이모지 |
| **02** | 질문 | **Up/Down 게임 기억나요?** 🎮 "50!" → "UP!" → "75!" → "DOWN!" → "62!" → "정답!" **반씩 줄여가며 찾는 게 이진 탐색!** | Up/Down 게임 |
| **03** | 비교 | **선형 vs 이진 탐색** 100만 개 데이터에서 찾기: 🐢 선형 탐색: 최대 100만 번 ⚡ 이진 탐색: 최대 20번! **50,000배 차이!** | 속도 비교 |
| **04** | 목표 | **오늘의 미션!** ☐ 1. 이진 탐색 원리 이해 ☐ 2. 직접 구현하기 ☐ 3. 선형 탐색과 비교 ☐ 4. 숫자 맞추기 게임 분석 | 점선 박스 |

---

### PART 2. 이진 탐색 원리 (Concept 1) : 6장

**목표: 이진 탐색의 동작 원리 이해**

| 번호 | 유형 | 화면 구성 및 내용 | 디자인/연출 포인트 |
|------|------|-------------------|-------------------|
| **05** | 개념 | **이진 탐색이란?** ⚡ 정렬된 데이터를 반씩 나눠가며 찾기! 1. 중간값 확인 2. 찾는 값과 비교 3. 반을 버리고 나머지에서 반복 | 반으로 나누기 |
| **06** | 주의 | **⚠️ 필수 조건: 정렬!** 이진 탐색은 **정렬된 데이터**에서만 가능! ❌ [5, 2, 8, 1, 9] → 안됨 ✅ [1, 2, 5, 8, 9] → 됨 정렬이 안 되어 있으면 선형 탐색! | 정렬 필수 |
| **07** | 그림 | **이진 탐색 과정** ``` [1, 3, 5, 7, 9, 11, 13] 에서 9 찾기 1단계: 중간(7) < 9 → 오른쪽만 확인 [9, 11, 13] 2단계: 중간(11) > 9 → 왼쪽만 확인 [9] 3단계: 중간(9) == 9 → 찾았다! ``` 3번 만에 발견! | 단계별 도식 |
| **08** | 비유 | **사전에서 단어 찾기** 📖 "Python"을 찾을 때: 1. 책 중간을 펼침 → M... P는 더 뒤 2. 뒷부분 중간 펼침 → R... P는 더 앞 3. 앞부분 중간 펼침 → P 발견! 우리도 이미 이진 탐색을 쓰고 있어요! | 사전 비유 |
| **09** | 개념 | **왜 빠를까?** 📊 매번 절반씩 줄어듦! N개 데이터: - 1번: N/2개 남음 - 2번: N/4개 남음 - 3번: N/8개 남음 - ... - log₂N번: 1개 남음 | 절반 감소 |
| **10** | 비교 | **시간 복잡도 비교** | | 선형 탐색 | 이진 탐색 | |---|---|---| | 복잡도 | O(N) | O(log N) | | 1000개 | 1000번 | 10번 | | 100만개 | 100만번 | 20번 | | 10억개 | 10억번 | 30번 | | 시간 복잡도 표 |

---

### PART 3. 이진 탐색 구현 (Concept 2) : 6장

**목표: 파이썬으로 이진 탐색 구현**

| 번호 | 유형 | 화면 구성 및 내용 | 디자인/연출 포인트 |
|------|------|-------------------|-------------------|
| **11** | 코드 | **이진 탐색 구현** ```python def binary_search(lst, target):     left = 0     right = len(lst) - 1     while left <= right:         mid = (left + right) // 2         if lst[mid] == target:             return mid  # 찾았다!         elif lst[mid] < target:             left = mid + 1  # 오른쪽 탐색         else:             right = mid - 1  # 왼쪽 탐색     return -1  # 못 찾음 ``` | 코드 블록 |
| **12** | 개념 | **변수 설명** - `left`: 탐색 범위의 왼쪽 끝 - `right`: 탐색 범위의 오른쪽 끝 - `mid`: 중간 위치 `(left + right) // 2` | 변수 설명 |
| **13** | 그림 | **동작 과정 시각화** ``` [1, 3, 5, 7, 9] 에서 7 찾기 left=0, right=4, mid=2: 5 < 7 left=3, right=4, mid=3: 7 == 7 찾음! ``` | 과정 그림 |
| **14** | 코드 | **테스트** ```python numbers = [1, 3, 5, 7, 9, 11, 13, 15] print(binary_search(numbers, 7))   # 3 print(binary_search(numbers, 1))   # 0 print(binary_search(numbers, 15))  # 7 print(binary_search(numbers, 4))   # -1 ``` | 테스트 코드 |
| **15** | 코드 | **과정 출력 버전** ```python def binary_search_verbose(lst, target):     left, right = 0, len(lst) - 1     step = 1     while left <= right:         mid = (left + right) // 2         print(f"{step}단계: [{left}:{right}] 중간값 {lst[mid]}")         if lst[mid] == target:             print(f"→ 찾았다! (인덱스 {mid})")             return mid         elif lst[mid] < target:             print(f"→ {lst[mid]} < {target}, 오른쪽 탐색")             left = mid + 1         else:             print(f"→ {lst[mid]} > {target}, 왼쪽 탐색")             right = mid - 1         step += 1     return -1 ``` | 디버깅 버전 |
| **16** | 코드 | **bisect 모듈** ```python import bisect numbers = [1, 3, 5, 7, 9] # 삽입 위치 찾기 pos = bisect.bisect_left(numbers, 6) print(pos)  # 3 (5와 7 사이) # 정렬 유지하며 삽입 bisect.insort(numbers, 6) print(numbers)  # [1, 3, 5, 6, 7, 9] ``` 파이썬 내장 이진 탐색! | bisect 모듈 |

---

### PART 4. 실습 A - 성능 비교 (Practice A) : 5장

**목표: 선형 탐색과 이진 탐색 성능 비교**

| 번호 | 유형 | 화면 구성 및 내용 | 디자인/연출 포인트 |
|------|------|-------------------|-------------------|
| **17** | 안내 | **실습 A: 성능 비교** ⏱️ 같은 데이터에서 두 탐색 방법의 시간 비교! | 성능 비교 |
| **18** | 실습 | **비교 코드** ```python import time import random # 100만 개 정렬된 데이터 data = list(range(1000000)) target = 999999  # 최악의 경우 # 선형 탐색 시간 start = time.time() for i, v in enumerate(data):     if v == target:         break linear_time = time.time() - start # 이진 탐색 시간 start = time.time() binary_search(data, target) binary_time = time.time() - start print(f"선형 탐색: {linear_time:.6f}초") print(f"이진 탐색: {binary_time:.6f}초") print(f"속도 차이: {linear_time/binary_time:.0f}배!") ``` | 코드 블록 |
| **19** | 완료 | **실행 결과** ``` 선형 탐색: 0.123456초 이진 탐색: 0.000012초 속도 차이: 10000배! ``` 이진 탐색이 훨씬 빠름! | 터미널 결과 |
| **20** | 실습 | **다양한 크기 테스트** ```python for size in [1000, 10000, 100000, 1000000]:     data = list(range(size))     target = size - 1     # 시간 측정...     print(f"데이터 {size}개:")     print(f"  선형: {linear_time:.6f}초")     print(f"  이진: {binary_time:.6f}초") ``` | 다양한 크기 |
| **21** | 정리 | **결론** 📊 데이터가 많을수록 차이가 커짐! - 작은 데이터: 큰 차이 없음 - 큰 데이터: 이진 탐색 필수! 단, **정렬된 데이터**에서만 사용! | 결론 |

---

### PART 5. 실습 B - Up/Down 분석 (Practice B) : 6장

**목표: Up/Down 게임을 이진 탐색으로 분석**

| 번호 | 유형 | 화면 구성 및 내용 | 디자인/연출 포인트 |
|------|------|-------------------|-------------------|
| **22** | 안내 | **실습 B: Up/Down 게임 분석** 🎮 17차시에 만든 Up/Down 게임! 사실 이건 이진 탐색의 원리예요! | 게임 연결 |
| **23** | 개념 | **최적의 전략** 1~100 사이 숫자 맞추기: 1. 50 추측 → UP/DOWN 2. 범위 반으로 줄임 3. 다시 중간값 추측 이렇게 하면 **최대 7번**에 맞출 수 있어요! log₂100 ≈ 7 | 최적 전략 |
| **24** | 코드 | **컴퓨터 자동 플레이** ```python def auto_guess(answer, low=1, high=100):     attempts = 0     while low <= high:         attempts += 1         guess = (low + high) // 2         print(f"{attempts}번째: {guess} 추측")         if guess == answer:             print(f"정답! {attempts}번 만에 맞춤")             return attempts         elif guess < answer:             print("→ UP!")             low = guess + 1         else:             print("→ DOWN!")             high = guess - 1 auto_guess(73) ``` | 코드 블록 |
| **25** | 완료 | **실행 결과** ``` 1번째: 50 추측 → UP! 2번째: 75 추측 → DOWN! 3번째: 62 추측 → UP! 4번째: 68 추측 → UP! 5번째: 71 추측 → UP! 6번째: 73 추측 정답! 6번 만에 맞춤 ``` | 터미널 결과 |
| **26** | 코드 | **평균 횟수 계산** ```python total = 0 for answer in range(1, 101):     attempts = auto_guess_silent(answer)     total += attempts avg = total / 100 print(f"평균 시도 횟수: {avg:.2f}번") # 약 5.8번 ``` 평균 6번 이하로 맞출 수 있어요! | 평균 계산 |
| **27** | 정리 | **게임과 알고리즘** 🎮 Up/Down 게임 = 이진 탐색 응용! 재미있는 게임이 사실은 효율적인 알고리즘! | 게임-알고리즘 연결 |

---

### PART 6. 이진 탐색 응용 (Advanced) : 4장

**목표: 다양한 이진 탐색 응용**

| 번호 | 유형 | 화면 구성 및 내용 | 디자인/연출 포인트 |
|------|------|-------------------|-------------------|
| **28** | 개념 | **이진 탐색 활용** 📖 사전에서 단어 찾기 📞 전화번호부 검색 🔢 정렬된 데이터 검색 🎮 게임 AI (가장 좋은 수 찾기) | 활용 사례 |
| **29** | 코드 | **범위 내 첫 번째 찾기** ```python def first_occurrence(lst, target):     left, right = 0, len(lst) - 1     result = -1     while left <= right:         mid = (left + right) // 2         if lst[mid] == target:             result = mid             right = mid - 1  # 더 왼쪽 탐색         elif lst[mid] < target:             left = mid + 1         else:             right = mid - 1     return result # [1, 2, 2, 2, 3]에서 2의 첫 위치 = 1 ``` | 응용 코드 |
| **30** | 코드 | **제곱근 구하기** ```python def sqrt_binary(n):     left, right = 0, n     while left <= right:         mid = (left + right) // 2         if mid * mid == n:             return mid         elif mid * mid < n:             left = mid + 1         else:             right = mid - 1     return right  # 정수 부분 print(sqrt_binary(16))  # 4 print(sqrt_binary(10))  # 3 ``` 이진 탐색으로 제곱근! | 응용 코드 |
| **31** | 정리 | **선형 vs 이진 정리** | | 선형 탐색 | 이진 탐색 | |---|---|---| | 정렬 필요 | ❌ | ✅ | | 시간 복잡도 | O(N) | O(log N) | | 구현 | 쉬움 | 중간 | | 언제 사용 | 작은 데이터, 비정렬 | 큰 데이터, 정렬 | | 비교표 |

---

### PART 7. 마무리 (Finish) : 4장

**목표: 정리 및 다음 차시 예고**

| 번호 | 유형 | 화면 구성 및 내용 | 디자인/연출 포인트 |
|------|------|-------------------|-------------------|
| **32** | 도전 | **도전 과제!** 🏆 이진 탐색으로 숫자 야구 힌트 분석기! 가능한 숫자 범위를 좁혀가며 정답 찾기! | 도전 문제 |
| **33** | 정리 | **오늘 배운 것** ✅ 이진 탐색 = 반으로 나눠서 찾기 ✅ 시간 복잡도 O(log N) ✅ 정렬된 데이터에서만 사용 ✅ Up/Down 게임 = 이진 탐색! | 체크리스트 |
| **34** | 예고 | **다음 시간에는...** 📊 정렬 알고리즘! 데이터를 순서대로 정리하는 방법! | 배경: #FFD506, 정렬 이모지 |
| **35** | 엔딩 | **수고했어요!** ⚡ 이진 탐색 완전 정복! **23차시 완료** | 엔딩 로고 |

---

## 3. 제작 시 유의사항 (Checklist)

1. **반으로 나누기 비유**: 이진 탐색의 직관적 이해
2. **정렬 필수 강조**: 정렬 안 되면 사용 불가
3. **Up/Down 게임 연결**: 17차시와 연결
4. **성능 비교**: 선형 탐색과의 차이 강조
5. **실습 코드**: `code/23-*.py` 파일과 일치 확인

---

## 4. 관련 코드 파일

| 파일명 | 내용 |
|--------|------|
| `23-1-binary_search.py` | 이진 탐색 기초 |
| `23-2-practice_compare.py` | 실습 A: 성능 비교 |
| `23-3-practice_game.py` | 실습 B: Up/Down 분석 |
| `23-4-challenge.py` | 도전 과제 |
| `23-5-answer.py` | 도전 과제 정답 |
