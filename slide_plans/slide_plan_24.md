# [슬라이드 기획안] 24차시: 정렬 알고리즘

## 1. 기획 개요

| 항목 | 내용 |
|------|------|
| **수업명** | [해달에듀] 파이썬 프로그래밍 24차시 - 정렬 알고리즘 |
| **대상** | 초중고 학생 (코딩 초보자) |
| **총 슬라이드** | 35장 |
| **학습 목표** | 버블 정렬의 원리를 이해하고, 파이썬 내장 정렬 함수를 활용할 수 있다 |
| **실습 코드** | `24-1-bubble_sort.py`, `24-2-practice_sort.py` |
| **디자인 컨셉** | 메인 컬러: #FFD506, 정리/순서 비유 |

---

## 2. 상세 슬라이드 구성안

### PART 1. 도입 (Intro) : 4장

**목표: 흥미 유발 및 정렬 소개**

| 번호 | 유형 | 화면 구성 및 내용 | 디자인/연출 포인트 |
|------|------|-------------------|-------------------|
| **01** | 표지 | **[제목] 순서대로 정리하기!** 📊 정렬 알고리즘 **[부제] 24차시 \| 해달에듀** | 배경: #FFD506, 정렬 이모지 |
| **02** | 질문 | **왜 정렬이 필요할까요?** 📚 책장 정리 (가나다순) 📞 연락처 검색 (이름순) 🏆 순위표 (점수순) **정렬 = 데이터를 순서대로!** | 정렬 필요성 |
| **03** | 미리보기 | **오늘의 완성작!** 🫧 버블 정렬 직접 구현 📊 다양한 정렬 활용 | 완성작 미리보기 |
| **04** | 목표 | **오늘의 미션!** ☐ 1. 정렬의 개념 이해 ☐ 2. 버블 정렬 구현 ☐ 3. 파이썬 내장 정렬 ☐ 4. 다양한 정렬 활용 | 점선 박스 |

---

### PART 2. 정렬 개념 (Concept 1) : 5장

**목표: 정렬의 개념과 종류 소개**

| 번호 | 유형 | 화면 구성 및 내용 | 디자인/연출 포인트 |
|------|------|-------------------|-------------------|
| **05** | 개념 | **정렬(Sorting)이란?** 📊 데이터를 특정 순서로 배열하기! - 오름차순: 작은 것 → 큰 것 - 내림차순: 큰 것 → 작은 것 [3, 1, 4, 1, 5] → [1, 1, 3, 4, 5] | 정렬 개념 |
| **06** | 개념 | **정렬 알고리즘 종류** | 알고리즘 | 특징 | |----------|--------| | 버블 정렬 | 간단, 느림 | | 선택 정렬 | 간단, 느림 | | 삽입 정렬 | 간단, 거의 정렬 시 빠름 | | 퀵 정렬 | 빠름, 복잡 | | 병합 정렬 | 빠름, 안정적 | 오늘은 버블 정렬! | 정렬 종류 |
| **07** | 비유 | **정렬의 필요성** 📚 책이 정리 안 된 책장: 매번 다 뒤져야 함 📚 가나다순 정리된 책장: 바로 찾음! 정렬 → 이진 탐색 가능! | 정리된 책장 |
| **08** | 개념 | **안정성(Stable)** 📊 같은 값의 원래 순서 유지? [3a, 2, 3b, 1] 정렬 후: 안정: [1, 2, 3a, 3b] 불안정: [1, 2, 3b, 3a] (순서 바뀜) | 안정성 개념 |
| **09** | 정리 | **정렬 특성** - 오름차순 / 내림차순 - 제자리(in-place) / 추가 메모리 - 안정 / 불안정 | 특성 정리 |

---

### PART 3. 버블 정렬 (Concept 2) : 7장

**목표: 버블 정렬 원리와 구현**

| 번호 | 유형 | 화면 구성 및 내용 | 디자인/연출 포인트 |
|------|------|-------------------|-------------------|
| **10** | 개념 | **버블 정렬이란?** 🫧 거품처럼 큰 값이 위로 떠오름! 인접한 두 요소를 비교하며 교환! ``` [5, 3, 8, 2] → [3, 5, 8, 2] → [3, 5, 2, 8] ``` | 버블 비유 |
| **11** | 그림 | **버블 정렬 과정** ``` [5, 3, 8, 2] 1회전: 5>3 교환 [3, 5, 8, 2]        5<8 그대로 [3, 5, 8, 2]        8>2 교환 [3, 5, 2, 8] → 8 확정 2회전: [3, 5, 2, 8] → [3, 2, 5, 8] → 5 확정 3회전: [3, 2, 5, 8] → [2, 3, 5, 8] → 완료! ``` | 단계별 과정 |
| **12** | 코드 | **버블 정렬 구현 (기본)** ```python def bubble_sort(lst):     n = len(lst)     for i in range(n - 1):         for j in range(n - 1 - i):             if lst[j] > lst[j + 1]:                 # 교환                 lst[j], lst[j+1] = lst[j+1], lst[j]     return lst nums = [5, 3, 8, 2, 7] print(bubble_sort(nums))  # [2, 3, 5, 7, 8] ``` | 코드 블록 |
| **13** | 개념 | **코드 설명** - 바깥 반복: n-1번 반복 (회전) - 안쪽 반복: 비교 & 교환 - `n-1-i`: 이미 정렬된 부분 제외 - 교환: 파이썬 스왑 `a, b = b, a` | 코드 설명 |
| **14** | 코드 | **과정 출력 버전** ```python def bubble_sort_verbose(lst):     n = len(lst)     for i in range(n - 1):         print(f"\\n{i+1}회전:")         for j in range(n - 1 - i):             if lst[j] > lst[j + 1]:                 lst[j], lst[j+1] = lst[j+1], lst[j]                 print(f"  교환: {lst}")             else:                 print(f"  유지: {lst}")     return lst ``` | 디버깅 버전 |
| **15** | 코드 | **최적화 버전** ```python def bubble_sort_optimized(lst):     n = len(lst)     for i in range(n - 1):         swapped = False         for j in range(n - 1 - i):             if lst[j] > lst[j + 1]:                 lst[j], lst[j+1] = lst[j+1], lst[j]                 swapped = True         if not swapped:  # 교환 없으면 이미 정렬됨             break     return lst ``` 이미 정렬되면 조기 종료! | 최적화 |
| **16** | 개념 | **버블 정렬 시간 복잡도** ⏱️ 최악: O(N²) - N개 × N번 비교 ⏱️ 최선: O(N) - 이미 정렬된 경우 (최적화 시) 📊 100개 → 최대 10,000번 비교 📊 1000개 → 최대 1,000,000번 비교 | 시간 복잡도 |

---

### PART 4. 파이썬 내장 정렬 (Concept 3) : 5장

**목표: sort()와 sorted() 활용**

| 번호 | 유형 | 화면 구성 및 내용 | 디자인/연출 포인트 |
|------|------|-------------------|-------------------|
| **17** | 코드 | **sort() 메서드** ```python nums = [5, 3, 8, 2, 7] nums.sort()  # 원본 수정 print(nums)  # [2, 3, 5, 7, 8] # 내림차순 nums.sort(reverse=True) print(nums)  # [8, 7, 5, 3, 2] ``` 원본 리스트가 바뀜! | 코드 블록 |
| **18** | 코드 | **sorted() 함수** ```python nums = [5, 3, 8, 2, 7] new_nums = sorted(nums)  # 새 리스트 반환 print(nums)      # [5, 3, 8, 2, 7] (원본 유지) print(new_nums)  # [2, 3, 5, 7, 8] ``` 원본 유지, 새 리스트 반환! | 코드 블록 |
| **19** | 비교 | **sort() vs sorted()** | | sort() | sorted() | |---|---|---| | 타입 | 메서드 | 함수 | | 반환 | None | 새 리스트 | | 원본 | 수정됨 | 유지됨 | | 대상 | 리스트만 | 모든 반복 가능 | | 비교표 |
| **20** | 코드 | **key 매개변수** ```python words = ["banana", "apple", "Cherry"] # 기본 (대소문자 구분) print(sorted(words))  # ['Cherry', 'apple', 'banana'] # 소문자 기준 print(sorted(words, key=str.lower)) # ['apple', 'banana', 'Cherry'] # 길이 기준 print(sorted(words, key=len)) # ['apple', 'banana', 'Cherry'] ``` | key 사용 |
| **21** | 코드 | **복잡한 정렬** ```python students = [     {"name": "철수", "score": 85},     {"name": "영희", "score": 92},     {"name": "민수", "score": 78} ] # 점수순 정렬 by_score = sorted(students, key=lambda x: x["score"]) # 점수 내림차순 by_score_desc = sorted(students, key=lambda x: x["score"], reverse=True) ``` | 딕셔너리 정렬 |

---

### PART 5. 실습 (Practice) : 6장

**목표: 다양한 정렬 활용**

| 번호 | 유형 | 화면 구성 및 내용 | 디자인/연출 포인트 |
|------|------|-------------------|-------------------|
| **22** | 안내 | **실습: 성적 관리 시스템** 📊 학생 점수를 다양한 기준으로 정렬! | 실습 안내 |
| **23** | 실습 | **데이터 준비** ```python students = [     {"name": "김철수", "kor": 85, "eng": 90, "math": 78},     {"name": "이영희", "kor": 92, "eng": 88, "math": 95},     {"name": "박민수", "kor": 78, "eng": 85, "math": 82},     {"name": "정지수", "kor": 88, "eng": 92, "math": 90},     {"name": "최예진", "kor": 95, "eng": 78, "math": 88} ] # 총점 계산 for s in students:     s["total"] = s["kor"] + s["eng"] + s["math"] ``` | 코드 블록 |
| **24** | 실습 | **다양한 정렬** ```python # 이름순 by_name = sorted(students, key=lambda x: x["name"]) # 총점 순위 (내림차순) by_total = sorted(students, key=lambda x: x["total"], reverse=True) # 수학 점수순 by_math = sorted(students, key=lambda x: x["math"], reverse=True) print("총점 순위:") for i, s in enumerate(by_total, 1):     print(f"{i}위: {s['name']} ({s['total']}점)") ``` | 코드 블록 |
| **25** | 완료 | **실행 결과** ``` 총점 순위: 1위: 이영희 (275점) 2위: 정지수 (270점) 3위: 최예진 (261점) 4위: 김철수 (253점) 5위: 박민수 (245점) ``` | 터미널 결과 |
| **26** | 실습 | **다중 기준 정렬** ```python # 수학 점수 같으면 국어 점수순 sorted_students = sorted(students, key=lambda x: (-x["math"], -x["kor"])) # 튜플로 여러 기준 sorted_students = sorted(students, key=lambda x: (x["total"], x["name"]), reverse=True) ``` 여러 기준으로 정렬! | 다중 기준 |
| **27** | 확장 | **정렬 시각화** ```python import random nums = [random.randint(1, 50) for _ in range(10)] print("정렬 전:", nums) for i in range(len(nums)):     for j in range(len(nums) - 1 - i):         if nums[j] > nums[j + 1]:             nums[j], nums[j+1] = nums[j+1], nums[j]     # 막대 그래프로 시각화     bars = " ".join("█" * (n // 5) for n in nums)     print(f"{i+1}회전: {bars}") ``` | 시각화 |

---

### PART 6. 정렬 비교 (Advanced) : 4장

**목표: 여러 정렬 알고리즘 비교**

| 번호 | 유형 | 화면 구성 및 내용 | 디자인/연출 포인트 |
|------|------|-------------------|-------------------|
| **28** | 개념 | **정렬 알고리즘 비교** | 알고리즘 | 평균 | 최악 | 안정 | |----------|------|------|------| | 버블 | O(N²) | O(N²) | ✅ | | 선택 | O(N²) | O(N²) | ❌ | | 삽입 | O(N²) | O(N²) | ✅ | | 퀵 | O(N log N) | O(N²) | ❌ | | 병합 | O(N log N) | O(N log N) | ✅ | | 파이썬 | O(N log N) | O(N log N) | ✅ | 파이썬의 Timsort가 최고! | 비교표 |
| **29** | 코드 | **성능 비교** ```python import time import random data = [random.randint(1, 10000) for _ in range(5000)] # 버블 정렬 start = time.time() bubble_sort(data.copy()) bubble_time = time.time() - start # 파이썬 정렬 start = time.time() sorted(data) python_time = time.time() - start print(f"버블 정렬: {bubble_time:.4f}초") print(f"파이썬 정렬: {python_time:.6f}초") ``` | 성능 비교 |
| **30** | 정리 | **실전 팁** 💡 직접 구현: 학습용으로만! 💡 실제 사용: `sort()`, `sorted()` 💡 key 활용: 복잡한 정렬 기준 💡 reverse=True: 내림차순 | 실전 팁 |
| **31** | 정리 | **정렬 선택 가이드** - 작은 데이터, 학습: 버블/선택/삽입 - 큰 데이터, 실전: 파이썬 내장 - 안정성 필요: 병합, 파이썬 내장 - 메모리 제한: 제자리 정렬 | 선택 가이드 |

---

### PART 7. 마무리 (Finish) : 4장

**목표: 정리 및 다음 차시 예고**

| 번호 | 유형 | 화면 구성 및 내용 | 디자인/연출 포인트 |
|------|------|-------------------|-------------------|
| **32** | 도전 | **도전 과제!** 🏆 선택 정렬 구현하기! 가장 작은 값을 찾아 앞으로 보내기! | 도전 문제 |
| **33** | 정리 | **오늘 배운 것** ✅ 버블 정렬: 인접 요소 비교 & 교환 ✅ 시간 복잡도: O(N²) ✅ sort(): 원본 수정 ✅ sorted(): 새 리스트 반환 ✅ key: 정렬 기준 지정 | 체크리스트 |
| **34** | 예고 | **다음 시간에는...** 🏆 종합 챌린지! 지금까지 배운 모든 것 총동원! | 배경: #FFD506, 종합 |
| **35** | 엔딩 | **수고했어요!** 📊 정렬 알고리즘 완전 정복! **24차시 완료** | 엔딩 로고 |

---

## 3. 제작 시 유의사항 (Checklist)

1. **버블 비유**: 거품이 떠오르듯 큰 값이 위로
2. **내장 함수 권장**: 실전은 sort()/sorted()
3. **시간 복잡도**: O(N²)의 의미 간단히
4. **key 활용**: 다양한 정렬 기준 실습
5. **실습 코드**: `code/24-*.py` 파일과 일치 확인

---

## 4. 관련 코드 파일

| 파일명 | 내용 |
|--------|------|
| `24-1-bubble_sort.py` | 버블 정렬 구현 |
| `24-2-practice_sort.py` | 정렬 활용 실습 |
| `24-3-challenge.py` | 도전 과제 (선택 정렬) |
| `24-4-answer.py` | 도전 과제 정답 |
